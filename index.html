<!DOCTYPE html>
<html class='no-js'>
    <head>
        <meta charset='utf-8'>
        <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
        <title>Life</title>
        <meta name='description' content=''>
        <meta name='viewport' content='width=device-width'>

        <link rel='stylesheet' href='css/normalize.min.css'>
        <link rel='stylesheet' href='css/main.css'>

        <script src='js/vendor/jquery-2.1.0.min.js'></script>
        <script src='js/vendor/jquery.mousewheel.js'></script>
        <script src='js/vendor/stats.js'></script>
        <!-- <script src='js/vendor/gl-matrix.js'></script> -->
    </head>
    <body>

        <canvas id='canvas' oncontextmenu="return false;"></canvas>

        <script id='vertex-shader' type='x-shader/x-vertex'>
            attribute vec2 a_position;

            varying vec2 v_texCoord;


            void main() {
                vec2 clipSpace = a_position * 2.0 - 1.0;
               
                gl_Position = vec4(clipSpace, 0, 1);

                v_texCoord = a_position;
            }
        </script>
        
        <script id='cell-iteration-shader' type='x-shader/x-fragment'>
            precision mediump float;

            uniform vec2 u_bufferResolution;
            uniform vec4 u_surface;
            uniform sampler2D u_buffer;

            varying vec2 v_texCoord;

            #define COLOR vec4(1, 1, 1, 1)
            #define BACKGROUND vec4(1, 1, 1, 1)
            #define DECAY vec4(1, 0.03, 0.002, 1)

            int isAlive(int x, int y) {

                vec2 onePixel = vec2(1.0, 1.0) / u_bufferResolution;
                if (texture2D(u_buffer, fract(v_texCoord + vec2(x, y) * onePixel)).a > 0.) 
                    return 1;
                else 
                    return 0;
            }

            void main() {

                int n = isAlive(0, 1)
                      + isAlive(1, 1)
                      + isAlive(1, 0)
                      + isAlive(1, -1)
                      + isAlive(0, -1)
                      + isAlive(-1, -1)
                      + isAlive(-1, 0)
                      + isAlive(-1, 1);

                // alive
                if (isAlive(0, 0) == 1) {
                    if (n == 2 || n == 3)
                        gl_FragColor = COLOR;
                    else
                        gl_FragColor = texture2D(u_buffer, v_texCoord) - DECAY;

                }

                // dead
                else {
                    if (n == 3 || n == 7)
                        gl_FragColor = COLOR;
                    else
                        gl_FragColor = texture2D(u_buffer, v_texCoord) - DECAY;
                }
            }
        </script>

        <script id='mouse-shader' type='x-shader/x-fragment'>
            precision mediump float;

            uniform vec2 u_bufferResolution;
            uniform vec2 u_mouse;
            uniform float u_paintSize;
            uniform vec4 u_surface;
            uniform sampler2D u_buffer;

            varying vec2 v_texCoord;

            #define COLOR vec4(1, 1, 1, 1)

            float rand(vec2 co) {
                return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
            }

            void main() {

                vec2 mouseSector = fract(u_surface.wz + u_mouse * (u_surface.yx - u_surface.wz));
                    
                vec2 distance = abs(mouseSector - v_texCoord);
                distance = min(distance, 1. - distance);
                distance.x *= u_bufferResolution.x / u_bufferResolution.y;

                if ( dot(distance, distance) < u_paintSize )
                    gl_FragColor = COLOR * floor(rand(gl_FragCoord.xy) * 2.);
                else
                    gl_FragColor = texture2D(u_buffer, v_texCoord);
            }

        </script>

        <script id='screen-shader' type='x-shader/x-fragment'>
            precision mediump float;

            uniform sampler2D u_screenBuffer;
            uniform vec4 u_surface; //top, right, bottom left

            varying vec2 v_texCoord;

            void main() {

                vec2 uv = u_surface.wz + v_texCoord * (u_surface.yx - u_surface.wz);
                gl_FragColor = texture2D(u_screenBuffer, fract(uv));
            }

        </script>

        <script>
        (function($) { //scoping function to contain global variables

        $(document).ready(main);

        function BufferSize(width, height) {
            this.width = width;
            this.height = height;
        }

        function ScreenSize() {

            this.width = $(window).width();
            this.height = $(window).height() - 5;
        }

        function Surface() {
            this.top = 1;
            this.right = 1;
            this.bottom = 0;
            this.left = 0;
        }

        Surface.prototype.width = function() {
            return this.right - this.left;
        };

        Surface.prototype.height = function() {
            return this.top - this.bottom;
        };

        Surface.prototype.normalize = function() {

            this.top -= Math.floor(this.bottom);
            this.right -= Math.floor(this.left);
            this.bottom -= Math.floor(this.bottom);
            this.left -= Math.floor(this.left);
        };

        Surface.prototype.computeAspectRatio = function(screenW, screenH, bufferW, bufferH) {

            var s = screenW / screenH;
            var b = bufferW / bufferH;

            if (s < b){
                var center = this.left + this.width() / 2;
                var w = this.height() * (s / b) / 2;
                
                this.right = center + w;
                this.left = center - w;
            }
            else {
                var center = this.bottom + this.height() / 2;
                var h = this.width() * (b / s) / 2;
                
                this.top = center + h;
                this.bottom = center - h;
            }

            this.scaleConstant = screenW / bufferW;
            this.horizontalAspectRatio = s / b;
        };

        Surface.prototype.paintSize = function() {
            return this.width() * 0.00005;
        };

        function MouseProp() {

            this.x = 0;
            this.y = 0;
            this.lastX = this.x;
            this.lastY = this.y;
            this.leftClick = false;
            this.rightClick = false;
        }

        var gl;
        var frontBuffer, backBuffer;
        var cellProgram, mouseProgram, screenProgram;
        var screenSize, bufferSize, mouseProp, surface;
        var stats;

        function main() {
            init();
            animate();
        }

        function init() {
            initStats();
            
            mouseProp = new MouseProp();
            bufferSize = new BufferSize(2048, 2048);
            surface = new Surface();

            var canvas =  $('canvas');
            gl = canvas[0].getContext('webgl');

            cellProgram = initCellProgram();
            mouseProgram = initMouseProgram();
            screenProgram = initScreenProgram();

            createVertexShader(screenProgram);

            frontBuffer = createBuffer(bufferSize.width, bufferSize.height);
            backBuffer = createBuffer(bufferSize.width, bufferSize.height);

            $(window).resize(function(event) {
                screenSize = new ScreenSize();

                surface.computeAspectRatio(screenSize.width, screenSize.height, bufferSize.width, bufferSize.height);

                canvas.prop('width', screenSize.width);
                canvas.prop('height', screenSize.height);
            });
            $(window).trigger('resize');

            canvas.mousemove(function(event) {

                mouseProp.x = event.pageX;
                mouseProp.y = screenSize.height - event.pageY;
            });

            canvas.mousedown(function(event) {

                //left click
                if (event.which === 1){
                     mouseProp.leftClick = true;
                }

                //right click
                else if (event.which === 3){
                    mouseProp.rightClick = true;
                    mouseProp.lastX = mouseProp.x;
                    mouseProp.lastY = mouseProp.y;

                    canvas.bind('mousemove', panningHandler);
                }
           
            });

            canvas.mouseup(function(event) {
       
                //left click
                if (event.which === 1){
                     mouseProp.leftClick = false;
                }

                //right click
                else if (event.which === 3){
                    mouseProp.rightClick = false;
                    canvas.unbind('mousemove', panningHandler);
                }
            });

            function panningHandler(event) {

                var changeX = mouseProp.lastX - mouseProp.x;
                var changeY = mouseProp.lastY - mouseProp.y;

                var dx = surface.width() / screenSize.width; 
                var dy = surface.height() / screenSize.height;

                surface.top += dy * changeY;
                surface.right += dx * changeX;
                surface.bottom += dy * changeY;
                surface.left += dx * changeX;

                surface.normalize();

                mouseProp.lastX = mouseProp.x;
                mouseProp.lastY = mouseProp.y;
            }

            canvas.mousewheel(function(event) {

                var maxScale = 1;
                var minScale = 0.05;
                var scaleStep = 0.05 * event.deltaY;

                var width = surface.width();
                var height = surface.height();

                if ( (event.deltaY === 1 && Math.min(width, height) > minScale * surface.scaleConstant) || (event.deltaY === -1 && Math.max(width, height) < maxScale) ) {

                    mx = mouseProp.x / screenSize.width;
                    my = mouseProp.y / screenSize.height;

                    var dx = surface.left + mx * width - (surface.left + width / 2);
                    var dy = surface.bottom + my * height - (surface.bottom + height / 2);

                    // scale the surface centered around the mouse location
                    surface.top += dy - height * scaleStep;
                    surface.right += dx - width * scaleStep;
                    surface.bottom += dy + height * scaleStep;
                    surface.left += dx + width * scaleStep;

                    width = surface.width();
                    height = surface.height();

                    dx = surface.left + mx * width - (surface.left + width / 2);
                    dy = surface.bottom + my * height - (surface.bottom + height / 2);

                    // translate the surface back so that the mouse location is in the original area on screen
                    surface.top -= dy;
                    surface.right -= dx;
                    surface.bottom -= dy;

                    // recalculate the left side according to the aspect ratio to guarantee correct proportions
                    var width = surface.height() * surface.horizontalAspectRatio;
                    surface.left = surface.right - width;

                    surface.normalize();
                }
            });
        }

        function drawScene() {
            // front buffer
            gl.viewport(0, 0, bufferSize.width, bufferSize.height);

            gl.activeTexture(gl.TEXTURE0);
            
            swapBuffers();
            gl.useProgram(cellProgram);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

            if (mouseProp.leftClick) {

                swapBuffers();
                gl.useProgram(mouseProgram);
                mouseProgram.setUniformValues();
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            }

            // screen buffer
            gl.viewport(0, 0, screenSize.width, screenSize.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, frontBuffer.texture);
            
            gl.useProgram(screenProgram);
            screenProgram.setUniformValues();
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

        }

        function swapBuffers() {
            var tmp = frontBuffer;
            frontBuffer = backBuffer;
            backBuffer = tmp;

            gl.bindFramebuffer(gl.FRAMEBUFFER, frontBuffer);
            gl.bindTexture(gl.TEXTURE_2D, backBuffer.texture);
        }

        function initCellProgram() {

            var program = createProgram('#vertex-shader', '#cell-iteration-shader');

            var locBufferResolution = gl.getUniformLocation(program, 'u_bufferResolution');
            var locTexture          = gl.getUniformLocation(program, 'u_buffer');

            // static uniforms
            gl.useProgram(program);
            gl.uniform2f(locBufferResolution, bufferSize.width, bufferSize.height);
            gl.uniform1i(locTexture, 0);
            gl.useProgram(null);

            return program;
        }

        function initMouseProgram() {

            var program = createProgram('#vertex-shader', '#mouse-shader');

            var locBufferResolution = gl.getUniformLocation(program, 'u_bufferResolution');
            var locMouse            = gl.getUniformLocation(program, 'u_mouse');
            var locPaintSize        = gl.getUniformLocation(program, 'u_paintSize');
            var locSurface          = gl.getUniformLocation(program, 'u_surface');
            var locTexture          = gl.getUniformLocation(program, 'u_buffer');

            // static uniforms
            gl.useProgram(program);
            gl.uniform2f(locBufferResolution, bufferSize.width, bufferSize.height);
            gl.uniform1i(locTexture, 0);
            gl.useProgram(null);

            //dynamic uniforms
            program.setUniformValues = function() {
                gl.uniform2f(locMouse, mouseProp.x / screenSize.width, mouseProp.y / screenSize.height);
                gl.uniform1f(locPaintSize, surface.paintSize());
                gl.uniform4f(locSurface, surface.top, surface.right, surface.bottom, surface.left);
            }

            return program;
        }

        function initScreenProgram() {

            var program = createProgram('#vertex-shader', '#screen-shader');

            var locSurface = gl.getUniformLocation(program, 'u_surface');
            var locTexture = gl.getUniformLocation(program, 'u_screenBuffer');

            // static uniforms
            gl.useProgram(program);
            gl.uniform1i(locTexture, 1);
            gl.useProgram(null);

            // dynamic uniforms
            program.setUniformValues = function() {
                gl.uniform4f(locSurface, surface.top, surface.right, surface.bottom, surface.left);
            };

            return program;
        }

        function createVertexShader(program) {

            var locVertexCoords = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(locVertexCoords);
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            gl.vertexAttribPointer(locVertexCoords, 2, gl.FLOAT, false, 0, 0);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 0,
                0, 1,
                1, 1,
                1, 0]), gl.STATIC_DRAW);
        }

        function createBuffer(width, height) {

            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

            var buffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            buffer.texture = texture;

            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            return buffer;
        }

        function createProgram(vertexShaderID, fragmentShaderID) {

            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, $(vertexShaderID).text());
            gl.compileShader(vertexShader);

            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, $(fragmentShaderID).text());
            gl.compileShader(fragmentShader);

            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            return program;
        }

        function animate() {

            drawScene();
            stats.update();
            window.requestAnimationFrame(animate);
        }

        function initStats() {

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';
            document.body.appendChild(stats.domElement);
        }

        })(jQuery);
        </script>
    </body>
</html>
